import read_bvh
import numpy as np
from pathlib import Path
import transforms3d.euler as euler
import transforms3d.quaternions as quat

# Configuration and hierarchy load
standard_bvh_file = Path("train_data_bvh/standard.bvh")
weight_translation = 0.01
skeleton, non_end_bones = read_bvh.read_bvh_hierarchy.read_bvh_hierarchy(str(standard_bvh_file))

# Precompute channel layout and rotating joints
motion_channels = [
    (joint, ch)
    for joint, bone in skeleton.items()
    for ch in bone['channels']
]
joints_with_rot = [
    joint
    for joint, bone in skeleton.items()
    if any('rotation' in c.lower() for c in bone['channels'])
]


def generate_quad_traindata_from_bvh(src_bvh_folder, tar_traindata_folder):
    """
    Reads raw BVH files, converts each frame’s 3 Euler rotation channels into quaternions
    (plus scaled hip translation), and saves the result as .npy files.
    """
    src_path = Path(src_bvh_folder)
    dst_path = Path(tar_traindata_folder)
    dst_path.mkdir(parents=True, exist_ok=True)

    # Dimension of quaternion-encoded data: 3 hip + 4 per rotating joint
    qdim = 3 + 4 * len(joints_with_rot)

    for bvh_file in src_path.iterdir():
        # skip anything that's not a single-suffix .bvh (avoid .bvh.bvh)
        if bvh_file.suffix.lower() != '.bvh' or bvh_file.name.lower().endswith('.bvh.bvh'):
            continue
        if bvh_file.suffix.lower() != '.bvh':
            continue
        raw = read_bvh.parse_frames(str(bvh_file))  # shape [F, P]
        F = raw.shape[0]

        quad_data = np.zeros((F, qdim), dtype=np.float32)
        for i, frame in enumerate(raw):
            # Scale and record hip translation
            row = list(frame[:3] * weight_translation)

            # Convert Euler rotations to quaternions
            for joint in joints_with_rot:
                angles = [
                    frame[motion_channels.index((joint, ch))]
                    for ch in skeleton[joint]['channels']
                    if 'rotation' in ch.lower()
                ]
                rad = [angle * np.pi / 180.0 for angle in angles]
                q = euler.euler2quat(rad[0], rad[1], rad[2], axes='szxy')
                row.extend(q)

            quad_data[i] = row

        out_file = dst_path / f"{bvh_file.stem}.npy"
        np.save(str(out_file), quad_data)



def generate_bvh_from_quad_traindata(src_train_folder, tar_bvh_folder):
    """
    Reads quaternion‐encoded .npy files, converts quaternions back to Euler angles + translations,
    rebuilds the original BVH channel matrix, and writes .bvh files.
    """
    src_path = Path(src_train_folder)
    dst_path = Path(tar_bvh_folder)
    dst_path.mkdir(parents=True, exist_ok=True)

    n_params = len(motion_channels)

    for npy_file in src_path.iterdir():
        # only process .bvh.npy files generated by our converter
        if not npy_file.name.lower().endswith('.bvh.npy'):
            continue
        if npy_file.suffix.lower() != '.npy':
            continue
        arr = np.load(str(npy_file))  # shape [F, 3+4M]
        F = arr.shape[0]

        raw = np.zeros((F, n_params), dtype=np.float32)
        for i, row in enumerate(arr):
            # Undo hip scaling
            raw[i, :3] = row[:3] / weight_translation

            offset = 3
            for joint in joints_with_rot:
                q = row[offset:offset + 4]
                offset += 4
                R = np.asarray(quat.quat2mat(q), dtype=np.float64)
                rad = euler.mat2euler(R, axes='szxy')
                degs = [r * 180.0 / np.pi for r in rad]

                # Inject back into appropriate channels
                for ch in skeleton[joint]['channels']:
                    if 'rotation' in ch.lower():
                        idx = motion_channels.index((joint, ch))
                        raw[i, idx] = degs.pop(0)

        out_bvh = dst_path / npy_file.name.replace('.npy', '.bvh')
        read_bvh.write_frames(str(standard_bvh_file), str(out_bvh), raw)

    # ——— Cleanup: remove any single-suffix .bvh files — keep only *.bvh.bvh
    for f in dst_path.iterdir():
        if f.suffix.lower() == '.bvh' and not f.name.lower().endswith('.bvh.bvh'):
            f.unlink()


if __name__ == "__main__":
    # Example paths - replace with actual directories
    bvh_dir_path = "./train_data_bvh/martial/"
    quat_enc_dir_path = "./train_data_quad/martial/"
    bvh_reconstructed_quad_dir = "./reconstructed_quad_bvh_new/martial/"

    generate_quad_traindata_from_bvh(bvh_dir_path, quat_enc_dir_path)
    generate_bvh_from_quad_traindata(quat_enc_dir_path, bvh_reconstructed_quad_dir)
